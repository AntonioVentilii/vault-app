/* eslint-disable */

// @ts-nocheck

// This file was automatically generated by @icp-sdk/bindgen@0.1.2.
// You should NOT make any changes in this file as it will be overwritten.
// Additionally, you should also exclude this file from your linter and/or formatter to prevent it from being checked or modified.

import type { ActorMethod } from '@icp-sdk/core/agent';
import type { IDL } from '@icp-sdk/core/candid';
import type { Principal } from '@icp-sdk/core/principal';

export type AbortUploadResult = { Ok: null } | { Err: DirectoryError };
export interface Account {
	owner: Principal;
	subaccount: [] | [Uint8Array];
}
export type Args = { Upgrade: [] | [UpgradeArgs] } | { Init: InitArgs };
export interface BucketAuth {
	token: DownloadToken;
	bucket_id: Principal;
}
export interface CallerPaysIcrc2Tokens {
	ledger: Principal;
}
export interface CanisterStatus {
	cycles_balance: bigint;
	memory_usage_bytes: bigint;
	version: string;
	heap_memory_usage_bytes: bigint;
}
export interface ChunkLocation {
	chunk_index: number;
	bucket: Principal;
}
export type CommitUploadResult = { Ok: FileMeta } | { Err: DirectoryError };
export type CreateShareLinkResult = { Ok: Uint8Array } | { Err: DirectoryError };
export type DeleteFileResult = { Ok: null } | { Err: DirectoryError };
export type DirectoryError =
	| { AccountExpired: null }
	| { UploadSessionNotFound: null }
	| { AdminOnly: null }
	| { PaymentFailed: string }
	| { Unauthorized: null }
	| { LinkNotFound: null }
	| { FileNotFound: null }
	| { LinkExpired: null }
	| { InvalidRequest: string }
	| { NoWritableBuckets: null }
	| { TransferFailed: string }
	| { UploadIncomplete: { expected: number; uploaded: number } }
	| {
			QuotaExceeded: {
				requested: bigint;
				used: bigint;
				quota: bigint;
			};
	  };
export interface DownloadPlan {
	auth: Array<BucketAuth>;
	chunk_count: number;
	locations: Array<ChunkLocation>;
	chunk_size: number;
}
export interface DownloadToken {
	sig: Uint8Array;
	bucket_id: Principal;
	directory_id: Principal;
	expires_at: bigint;
	file_id: FileId;
}
export interface FileId {
	id: Uint8Array;
	owner: Principal;
}
export interface FileMeta {
	readers: Array<Principal>;
	status: FileStatus;
	sha256: [] | [Uint8Array];
	mime: string;
	name: string;
	size_bytes: bigint;
	updated_at_ns: bigint;
	created_at_ns: bigint;
	chunk_count: number;
	writers: Array<Principal>;
	chunk_size: number;
	file_id: FileId;
}
export type FileRole = { Reader: null } | { Writer: null };
export type FileStatus = { Ready: null } | { Deleted: null } | { Pending: null };
export type GetDownloadPlanResult = { Ok: DownloadPlan } | { Err: DirectoryError };
export type GetFileMetaResult = { Ok: FileMeta } | { Err: DirectoryError };
export type GetUploadTokensResult = { Ok: Array<UploadToken> } | { Err: DirectoryError };
export interface InitArgs {
	rate_per_gb_per_month: bigint;
	admins: Array<Principal>;
	shared_secret: Uint8Array;
}
export interface PatronPaysIcrc2Tokens {
	ledger: Principal;
	patron: Account;
}
export type PaymentType =
	| { PatronPaysIcrc2Tokens: PatronPaysIcrc2Tokens }
	| { AttachedCycles: null }
	| { CallerPaysIcrc2Cycles: null }
	| { CallerPaysIcrc2Tokens: CallerPaysIcrc2Tokens }
	| { PatronPaysIcrc2Cycles: Account };
export interface PricingConfig {
	rate_per_gb_per_month: bigint;
}
export type StartUploadResult = { Ok: UploadSession } | { Err: DirectoryError };
export type TopUpBalanceResult = { Ok: bigint } | { Err: DirectoryError };
export interface UpgradeArgs {
	rate_per_gb_per_month: [] | [bigint];
	admins: [] | [Array<Principal>];
	shared_secret: [] | [Uint8Array];
}
export interface UploadSession {
	expected_chunk_count: number;
	mime: string;
	name: string;
	upload_id: Uint8Array;
	expected_size_bytes: bigint;
	chunk_size: number;
	uploaded_chunks: Uint32Array;
	expires_at_ns: bigint;
	file_id: FileId;
}
export interface UploadToken {
	sig: Uint8Array;
	bucket_id: Principal;
	upload_id: Uint8Array;
	directory_id: Principal;
	expires_at: bigint;
	allowed_chunks: Uint32Array;
	file_id: FileId;
}
export interface UserState {
	used_bytes: bigint;
	prepaid_balance: bigint;
	quota_bytes: bigint;
	expires_at_ns: [] | [bigint];
}
export interface _SERVICE {
	abort_upload: ActorMethod<[Uint8Array], AbortUploadResult>;
	add_file_access: ActorMethod<[FileId, Principal, FileRole], AbortUploadResult>;
	admin_set_pricing: ActorMethod<[bigint], AbortUploadResult>;
	admin_set_quota: ActorMethod<[Principal, bigint], AbortUploadResult>;
	admin_withdraw: ActorMethod<[Principal, bigint, Principal], AbortUploadResult>;
	commit_upload: ActorMethod<[Uint8Array], CommitUploadResult>;
	create_share_link: ActorMethod<[FileId, bigint], CreateShareLinkResult>;
	delete_file: ActorMethod<[FileId], DeleteFileResult>;
	estimate_upload_cost: ActorMethod<[bigint, PaymentType], bigint>;
	garbage_collect: ActorMethod<[], undefined>;
	get_download_plan: ActorMethod<[FileId], GetDownloadPlanResult>;
	get_file_meta: ActorMethod<[FileId], GetFileMetaResult>;
	get_pricing: ActorMethod<[], PricingConfig>;
	get_status: ActorMethod<[], CanisterStatus>;
	get_upload_tokens: ActorMethod<[Uint8Array, Uint32Array], GetUploadTokensResult>;
	get_usage: ActorMethod<[[] | [Principal]], UserState>;
	list_files: ActorMethod<[], Array<FileMeta>>;
	provision_bucket: ActorMethod<[Principal], DeleteFileResult>;
	reap_expired_uploads: ActorMethod<[], undefined>;
	remove_file_access: ActorMethod<[FileId, Principal], DeleteFileResult>;
	report_chunk_uploaded: ActorMethod<[Uint8Array, number], DeleteFileResult>;
	resolve_share_link: ActorMethod<[Uint8Array], GetDownloadPlanResult>;
	revoke_share_link: ActorMethod<[Uint8Array], DeleteFileResult>;
	start_upload: ActorMethod<[string, string, bigint, [] | [PaymentType]], StartUploadResult>;
	top_up_balance: ActorMethod<[bigint, PaymentType], TopUpBalanceResult>;
}
export declare const idlService: IDL.ServiceClass;
export declare const idlInitArgs: IDL.Type[];
export declare const idlFactory: IDL.InterfaceFactory;
export declare const init: (args: { IDL: typeof IDL }) => IDL.Type[];
