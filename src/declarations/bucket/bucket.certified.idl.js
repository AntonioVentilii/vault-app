/* eslint-disable */

// @ts-nocheck

// This file was automatically generated by @icp-sdk/bindgen@0.1.2.
// You should NOT make any changes in this file as it will be overwritten.
// Additionally, you should also exclude this file from your linter and/or formatter to prevent it from being checked or modified.

import { IDL } from '@icp-sdk/core/candid';

export const UpgradeArgs = IDL.Record({
	admins: IDL.Opt(IDL.Vec(IDL.Principal)),
	shared_secret: IDL.Opt(IDL.Vec(IDL.Nat8))
});
export const InitArgs = IDL.Record({
	admins: IDL.Vec(IDL.Principal),
	shared_secret: IDL.Vec(IDL.Nat8)
});
export const Args = IDL.Variant({
	Upgrade: IDL.Opt(UpgradeArgs),
	Init: InitArgs
});
export const BucketError = IDL.Variant({
	ChunkNotFound: IDL.Null,
	AdminOnly: IDL.Null,
	WrongBucket: IDL.Null,
	PaymentFailed: IDL.Text,
	ChunkNotAllowed: IDL.Nat32,
	ReadOnly: IDL.Null,
	InvalidSignature: IDL.Null,
	TokenExpired: IDL.Null,
	Unauthorized: IDL.Null,
	Other: IDL.Text,
	InvalidFileId: IDL.Null
});
export const AdminSetReadOnlyResult = IDL.Variant({
	Ok: IDL.Null,
	Err: BucketError
});
export const AdminWithdrawResult = IDL.Variant({
	Ok: IDL.Null,
	Err: BucketError
});
export const FileId = IDL.Record({
	id: IDL.Vec(IDL.Nat8),
	owner: IDL.Principal
});
export const DeleteFileResult = IDL.Variant({
	Ok: IDL.Null,
	Err: BucketError
});
export const DownloadToken = IDL.Record({
	sig: IDL.Vec(IDL.Nat8),
	bucket_id: IDL.Principal,
	directory_id: IDL.Principal,
	expires_at: IDL.Nat64,
	file_id: FileId
});
export const GetChunkResult = IDL.Variant({
	Ok: IDL.Vec(IDL.Nat8),
	Err: BucketError
});
export const CanisterStatus = IDL.Record({
	cycles_balance: IDL.Nat,
	memory_usage_bytes: IDL.Nat64,
	version: IDL.Text,
	heap_memory_usage_bytes: IDL.Nat64
});
export const UploadToken = IDL.Record({
	sig: IDL.Vec(IDL.Nat8),
	bucket_id: IDL.Principal,
	upload_id: IDL.Vec(IDL.Nat8),
	directory_id: IDL.Principal,
	expires_at: IDL.Nat64,
	allowed_chunks: IDL.Vec(IDL.Nat32),
	file_id: FileId
});
export const Account = IDL.Record({
	owner: IDL.Principal,
	subaccount: IDL.Opt(IDL.Vec(IDL.Nat8))
});
export const PatronPaysIcrc2Tokens = IDL.Record({
	ledger: IDL.Principal,
	patron: Account
});
export const CallerPaysIcrc2Tokens = IDL.Record({ ledger: IDL.Principal });
export const PaymentType = IDL.Variant({
	PatronPaysIcrc2Tokens: PatronPaysIcrc2Tokens,
	AttachedCycles: IDL.Null,
	CallerPaysIcrc2Cycles: IDL.Null,
	CallerPaysIcrc2Tokens: CallerPaysIcrc2Tokens,
	PatronPaysIcrc2Cycles: Account
});
export const PutChunkResult = IDL.Variant({
	Ok: IDL.Nat32,
	Err: BucketError
});

export const idlService = IDL.Service({
	admin_set_read_only: IDL.Func([IDL.Bool], [AdminSetReadOnlyResult], []),
	admin_withdraw: IDL.Func([IDL.Principal, IDL.Nat64, IDL.Principal], [AdminWithdrawResult], []),
	delete_file: IDL.Func([FileId], [DeleteFileResult], []),
	get_chunk: IDL.Func([DownloadToken, IDL.Nat32], [GetChunkResult], []),
	get_status: IDL.Func([], [CanisterStatus], []),
	put_chunk: IDL.Func(
		[UploadToken, IDL.Nat32, IDL.Vec(IDL.Nat8), IDL.Opt(PaymentType)],
		[PutChunkResult],
		[]
	),
	stat: IDL.Func([], [IDL.Text], ['query'])
});

export const idlInitArgs = [Args];

export const idlFactory = ({ IDL }) => {
	const UpgradeArgs = IDL.Record({
		admins: IDL.Opt(IDL.Vec(IDL.Principal)),
		shared_secret: IDL.Opt(IDL.Vec(IDL.Nat8))
	});
	const InitArgs = IDL.Record({
		admins: IDL.Vec(IDL.Principal),
		shared_secret: IDL.Vec(IDL.Nat8)
	});
	const Args = IDL.Variant({
		Upgrade: IDL.Opt(UpgradeArgs),
		Init: InitArgs
	});
	const BucketError = IDL.Variant({
		ChunkNotFound: IDL.Null,
		AdminOnly: IDL.Null,
		WrongBucket: IDL.Null,
		PaymentFailed: IDL.Text,
		ChunkNotAllowed: IDL.Nat32,
		ReadOnly: IDL.Null,
		InvalidSignature: IDL.Null,
		TokenExpired: IDL.Null,
		Unauthorized: IDL.Null,
		Other: IDL.Text,
		InvalidFileId: IDL.Null
	});
	const AdminSetReadOnlyResult = IDL.Variant({
		Ok: IDL.Null,
		Err: BucketError
	});
	const AdminWithdrawResult = IDL.Variant({
		Ok: IDL.Null,
		Err: BucketError
	});
	const FileId = IDL.Record({
		id: IDL.Vec(IDL.Nat8),
		owner: IDL.Principal
	});
	const DeleteFileResult = IDL.Variant({
		Ok: IDL.Null,
		Err: BucketError
	});
	const DownloadToken = IDL.Record({
		sig: IDL.Vec(IDL.Nat8),
		bucket_id: IDL.Principal,
		directory_id: IDL.Principal,
		expires_at: IDL.Nat64,
		file_id: FileId
	});
	const GetChunkResult = IDL.Variant({
		Ok: IDL.Vec(IDL.Nat8),
		Err: BucketError
	});
	const CanisterStatus = IDL.Record({
		cycles_balance: IDL.Nat,
		memory_usage_bytes: IDL.Nat64,
		version: IDL.Text,
		heap_memory_usage_bytes: IDL.Nat64
	});
	const UploadToken = IDL.Record({
		sig: IDL.Vec(IDL.Nat8),
		bucket_id: IDL.Principal,
		upload_id: IDL.Vec(IDL.Nat8),
		directory_id: IDL.Principal,
		expires_at: IDL.Nat64,
		allowed_chunks: IDL.Vec(IDL.Nat32),
		file_id: FileId
	});
	const Account = IDL.Record({
		owner: IDL.Principal,
		subaccount: IDL.Opt(IDL.Vec(IDL.Nat8))
	});
	const PatronPaysIcrc2Tokens = IDL.Record({
		ledger: IDL.Principal,
		patron: Account
	});
	const CallerPaysIcrc2Tokens = IDL.Record({ ledger: IDL.Principal });
	const PaymentType = IDL.Variant({
		PatronPaysIcrc2Tokens: PatronPaysIcrc2Tokens,
		AttachedCycles: IDL.Null,
		CallerPaysIcrc2Cycles: IDL.Null,
		CallerPaysIcrc2Tokens: CallerPaysIcrc2Tokens,
		PatronPaysIcrc2Cycles: Account
	});
	const PutChunkResult = IDL.Variant({ Ok: IDL.Nat32, Err: BucketError });

	return IDL.Service({
		admin_set_read_only: IDL.Func([IDL.Bool], [AdminSetReadOnlyResult], []),
		admin_withdraw: IDL.Func([IDL.Principal, IDL.Nat64, IDL.Principal], [AdminWithdrawResult], []),
		delete_file: IDL.Func([FileId], [DeleteFileResult], []),
		get_chunk: IDL.Func([DownloadToken, IDL.Nat32], [GetChunkResult], []),
		get_status: IDL.Func([], [CanisterStatus], []),
		put_chunk: IDL.Func(
			[UploadToken, IDL.Nat32, IDL.Vec(IDL.Nat8), IDL.Opt(PaymentType)],
			[PutChunkResult],
			[]
		),
		stat: IDL.Func([], [IDL.Text], ['query'])
	});
};

export const init = ({ IDL }) => {
	const UpgradeArgs = IDL.Record({
		admins: IDL.Opt(IDL.Vec(IDL.Principal)),
		shared_secret: IDL.Opt(IDL.Vec(IDL.Nat8))
	});
	const InitArgs = IDL.Record({
		admins: IDL.Vec(IDL.Principal),
		shared_secret: IDL.Vec(IDL.Nat8)
	});
	const Args = IDL.Variant({
		Upgrade: IDL.Opt(UpgradeArgs),
		Init: InitArgs
	});

	return [Args];
};
